import _ from 'lodash';

import { JsCoder } from '../lib/JsCoder';
import { ModulesCoder } from '../lib/ModulesCoder';
import { IField, ITable } from '../model';
import { Config, CustomHarvests, CustomJsTypes } from './spec';

const IMPORT_PATH_TO_CONNECTION = '../../lib/mysql-promise';
const IMPORT_PATH_TO_SCHEME_TYPES = 'mrshop-scheme/dist/types';
const IMPORT_PATH_TO_SCHEME_ENTITY = 'mrshop-scheme/dist/entity/types';

function getImports(table: ITable, config: Config): string{
	const modules = new ModulesCoder();

	modules.importDefault('_', 'lodash');
	modules.importDefault('assert', 'assert');
	modules.import('Connection', IMPORT_PATH_TO_CONNECTION);

	for (const f of table.fields) {
		const jstypes = f.jstype.split(/[^a-zA-Z0-9_]+/);
		for (const jstype of jstypes) {
			if (!jstype.length) continue;

			if (CustomJsTypes.includes(jstype)) {
				modules.import(jstype, IMPORT_PATH_TO_SCHEME_TYPES);
			}
		}

		if (f.type === 'DATE') {
			modules.import('DateString', IMPORT_PATH_TO_SCHEME_TYPES);
		}
	}

	modules.import([table.entityName, table.entityName + 'Data'], IMPORT_PATH_TO_SCHEME_ENTITY);
	return modules.toString();
}

function getPrimaryKeys(table: ITable): IField[] {
	let keyFields = _.filter(table.fields, (f) => f.pk);

	if (!keyFields.length) {
		const pkconstraint = _.find(table.constraints, (c) => c.match(/^PRIMARY\ KEY\(.*\)$/) ? true : false);
		if (!pkconstraint) throw new Error('No primary key for table: ' + table.name);

		const keyNames = pkconstraint.replace(/PRIMARY\ KEY\((.*)\)/, '$1').split(/,\s*/);
		if (!keyNames.length) throw new Error('No field in PRIMARY KEY');

		keyFields = [];
		for (const keyName of keyNames) {
			const field = _.find(table.fields, {name: keyName});
			if (!field) throw new Error('No such field of name: ' + keyName);
			keyFields.push(field);
		}
	}

	return keyFields;
}

export const generate_entity = (table: ITable, config: Config): string => {
	const js = new JsCoder();
	js.add(`
	/* DO NOT EDIT THIS FILE:
	 * This file is generated by mrshop-gencode project.
	 */`);

	js.add(getImports(table, config));
	js.add('');

	const keys = getPrimaryKeys(table);
	const keyNames = _.map(keys, (k) => k.name);
	const keyArgs = _.map(keys, (k) => {
		return `${k.name}: ${k.jstype}`;
	});
	const pkWheres = _.map(keys, (k) => `${k.name}=?`);
	const pkParams = _.map(keys, (k) => `${k.name}`);

	// interface ~Filter
	js.add(`export interface ${table.entityName}Filter {`);
	_.each(table.fields, (f) => {
		if (f.pk || f.notnull) {
			js.add(`${f.name}?: ${f.jstype};`);
		} else {
			js.add(`${f.name}?: ${f.jstype} | null;`);
		}
	});
	js.add('}');
	js.add('');

	// class ~Entity
	js.add(`export class ${table.entityName}Entity {`);

	js.add(`static harvestData(row: {[name: string]: any}, dest?: any): ${table.entityName}Data {`);
	_.each(table.fields, (f) => {
		if (_.find(keys, {name: f.name})) return;

		if (f.notnull) {
			if (f.type === 'JSON') {
				js.add(`assert.ok(_.isObject(row.${f.name}) || _.isString(row.${f.name}));`);
			} else if (/DATETIME(\([0-6]\))?/.test(f.type)) {
				js.add(`assert.ok(_.isDate(row.${f.name}) || _.isString(row.${f.name}));`);
			} else if (f.type === 'DATE') {
				js.add(`assert.ok(_.isDate(row.${f.name}) || DateString.isValid(row.${f.name}));`);
			} else if (f.jstype === 'number') {
				js.add(`assert.ok(_.isNumber(row.${f.name}));`);
			} else if (f.jstype === 'boolean') {
				js.add(`assert.ok(_.isBoolean(row.${f.name}) || _.isNumber(row.${f.name}));`);
			} else {
				js.add(`assert.notEqual(row.${f.name}, null);`);
			}
		}
	});
	js.add('');
	js.add(`if (!dest) dest = {};`);
	_.each(table.fields, (f) => {
		if (_.find(keys, {name: f.name})) return;

		const customHarvest = CustomHarvests[f.jstype];
		if (customHarvest) {
			js.add(customHarvest(f, 'row', 'dest'));
		} else if (f.type === 'JSON') {
			js.add(`
			if (_.isObject(row.${f.name})) dest.${f.name} = row.${f.name};
			else if (_.isString(row.${f.name})) dest.${f.name} = JSON.parse(row.${f.name});
			`);
		} else if (/DATETIME(\([0-6]\))?/.test(f.type)) {
			js.add(`
			if (_.isDate(row.${f.name})) dest.${f.name} = row.${f.name};
			else if (_.isString(row.${f.name})) dest.${f.name} = new Date(row.${f.name});
			`);
		} else if (f.type === 'DATE') {
			js.add(`
			if (_.isDate(row.${f.name})) dest.${f.name} = DateString.format(row.${f.name});
			else if (_.isString(row.${f.name})) dest.${f.name} = DateString.format(row.${f.name});
			`);
		} else if (f.jstype === 'number') {
			js.add(`
			if (_.isNumber(row.${f.name})) dest.${f.name} = row.${f.name};
			`);
		} else if (f.jstype === 'boolean') {
			js.add(`
			if (_.isBoolean(row.${f.name}) || _.isNumber(row.${f.name})) dest.${f.name} = (row.${f.name} ? true : false);
			`);
		} else {
			js.add(`
			if (row.${f.name} != null) dest.${f.name} = row.${f.name};
			`);
		}
	});
	js.add(`
		return dest;
	}`);
	js.add('');

	js.add(`static harvest(row: {[name: string]: any}, dest?: any): ${table.entityName} {`);
	_.each(keys, (f) => {
		if (f.type === 'JSON') {
			js.add(`assert.ok(_.isObject(row.${f.name}) || _.isString(row.${f.name}));`);
		} else if (/DATETIME(\([0-6]\))?/.test(f.type)) {
			js.add(`assert.ok(_.isDate(row.${f.name}) || _.isString(row.${f.name}));`);
		} else if (f.type === 'DATE') {
			js.add(`assert.ok(_.isDate(row.${f.name}) || DateString.isValid(row.${f.name}));`);
		} else if (f.jstype === 'number') {
			js.add(`assert.ok(_.isNumber(row.${f.name}));`);
		} else if (f.jstype === 'boolean') {
			js.add(`assert.ok(_.isBoolean(row.${f.name}) || _.isNumber(row.${f.name}));`);
		} else {
			js.add(`assert.notEqual(row.${f.name}, null);`);
		}
	});
	js.add('');
	js.add(`if (!dest) dest = {};`);
	_.each(keys, (f) => {
		const customHarvest = CustomHarvests[f.jstype];
		if (customHarvest) {
			js.add(customHarvest(f, 'row', 'dest'));
		} else if (f.type === 'JSON') {
			js.add(`
			if (_.isObject(row.${f.name})) dest.${f.name} = row.${f.name};
			else if (_.isString(row.${f.name})) dest.${f.name} = JSON.parse(row.${f.name});
			`);
		} else if (/DATETIME(\([0-6]\))?/.test(f.type)) {
			js.add(`
			if (_.isDate(row.${f.name})) dest.${f.name} = row.${f.name};
			else if (_.isString(row.${f.name})) dest.${f.name} = new Date(row.${f.name});
			`);
		} else if (f.type === 'DATE') {
			js.add(`
			if (_.isDate(row.${f.name})) dest.${f.name} = DateString.format(row.${f.name});
			if (_.isString(row.${f.name})) dest.${f.name} = DateString.format(row.${f.name});
			`);
		} else if (f.jstype === 'number') {
			js.add(`
			if (_.isNumber(row.${f.name})) dest.${f.name} = row.${f.name};
			`);
		} else if (f.jstype === 'boolean') {
			js.add(`
			if (_.isBoolean(row.${f.name}) || _.isNumber(row.${f.name})) dest.${f.name} = (row.${f.name} ? true : false);
			`);
		} else {
			js.add(`
			if (row.${f.name} != null) dest.${f.name} = row.${f.name};
			`);
		}
	});
	js.add('');
	js.add(`
			this.harvestData(row, dest);
		return dest;
	}`);
	js.add('');

	// static function _from()
	js.add(`
	static _from<T extends ${table.entityName}Entity>(row: {[name: string]: any}, conn: Connection, factory: (data: ${table.entityName}, conn: Connection) => T): T {
		const data = this.harvest(row);
		return factory(data, conn);
	}`);
	js.add('');

	// static function _find()
	if (table.fetchLock) {
		js.add(`
		static async _find<T extends ${table.entityName}Entity>(${keyArgs.join(', ')}, conn: Connection, factory: (data: ${table.entityName}, conn: Connection) => T, selectForUpdate?: boolean): Promise<T | undefined> {
			let rows: any[];
			if (selectForUpdate) {
				rows = await conn.query('SELECT * FROM ${table.name} WHERE ${pkWheres.join(' AND ')} FOR UPDATE', [${pkParams.join(', ')}]);
			} else {
				rows = await conn.query('SELECT * FROM ${table.name} WHERE ${pkWheres.join(' AND ')}', [${pkParams.join(', ')}]);
			}
		`);
	} else {
		js.add(`
		static async _find<T extends ${table.entityName}Entity>(${keyArgs.join(', ')}, conn: Connection, factory: (data: ${table.entityName}, conn: Connection) => T): Promise<T | undefined> {
			const rows = await conn.query('SELECT * FROM ${table.name} WHERE ${pkWheres.join(' AND ')}', [${pkParams.join(', ')}]);
		`);
	}
	js.add(`
		if (rows.length) {
			const row = rows[0];
			return ${table.entityName}Entity._from(row, conn, factory);
		}
	}`);
	js.add('');

	// static function _findBy()
	const rowPkNames = _.map(keys, (k) => `row.${k.name}`);
	js.add(`
	static async _findBy<T extends ${table.entityName}Entity>(by: ${table.entityName}Filter, conn: Connection, factory: (data: ${table.entityName}, conn: Connection) => T): Promise<T | undefined> {
		const wheres: string[] = [];
		const params: any[] = [];
		const keys = Object.keys(by);
		for (const key of keys) {
			const val = (by as any)[key];
			if (val === undefined || val === null) {
				wheres.push(\`\${key} IS NULL\`);
			} else {
				wheres.push(\`\${key}=?\`);
				params.push(val);
			}
		}

		const rows = await conn.query(\`SELECT * FROM ${table.name} WHERE \${wheres.join(' AND ')}\`, params);
		if (rows.length) {
			const row = rows[0];
			return ${table.entityName}Entity._from(row, conn, factory);
		}
	}`);
	js.add('');

	// static function _fetch()
	if (table.fetchLock) {
		js.add(`
		static async _fetch<T extends ${table.entityName}Entity>(${keyArgs.join(', ')}, conn: Connection, factory: (data: ${table.entityName}, conn: Connection) => T, selectForUpdate?: boolean): Promise<T> {
			const found = await ${table.entityName}Entity._find(${keyNames.join(', ')}, conn, factory, selectForUpdate);
		`);
	} else {
		js.add(`
		static async _fetch<T extends ${table.entityName}Entity>(${keyArgs.join(', ')}, conn: Connection, factory: (data: ${table.entityName}, conn: Connection) => T): Promise<T> {
			const found = await ${table.entityName}Entity._find(${keyNames.join(', ')}, conn, factory);
		`);
	}
	js.add(`
			if (!found) throw new Error(\`No such #${table.entityName}Entity{${_.map(keys, (k) => k.name + ': ${' + k.name + '}').join(', ')}}\`);
			return found;
		}`);
	js.add('');

	// static function _fetchAllBy()
	js.add(`
	static async _fetchAllBy<T extends ${table.entityName}Entity>(by: ${table.entityName}Filter, conn: Connection, factory: (data: ${table.entityName}, conn: Connection) => T): Promise<T[]> {
		const wheres: string[] = [];
		const params: any[] = [];
		const keys = Object.keys(by);
		for (const key of keys) {
			const val = (by as any)[key];
			if (val === undefined || val === null) {
				wheres.push(\`\${key} IS NULL\`);
			} else {
				wheres.push(\`\${key}=?\`);
				params.push(val);
			}
		}

		const rows = await conn.query(\`SELECT * FROM ${table.name} WHERE \${wheres.join(' AND ')} ORDER BY ${keyNames.join(', ')}\`, params);
		const all: T[] = [];
		for (const row of rows) {
			all.push(${table.entityName}Entity._from(row, conn, factory));
		}
		return all;
	}`);
	js.add('');

	// static function insert()
	if (keys.length === 1 && keys[0].auto_increment) {
		js.add(`
		static async insert<T extends ${table.entityName}Entity>(data: ${table.entityName}Data, conn: Connection, factory: (data: ${table.entityName}, conn: Connection) => T): Promise<T> {
		`);
	} else {
		js.add(`
		static async insert<T extends ${table.entityName}Entity>(${keyArgs.join(', ')}, data: ${table.entityName}Data, conn: Connection, factory: (data: ${table.entityName}, conn: Connection) => T, onDuplicateUpdate?: boolean): Promise<T> {
		`);
		_.each(keys, (f) => {
			js.add(`if (${f.name} == null) throw new Error('${table.entityName}Entity.${f.name} should have a value');`);
		});
	}
	_.each(table.fields, (f) => {
		if (!_.find(keys, {name: f.name}) && f.notnull) {
			js.add(`if (data.${f.name} == null) throw new Error('${table.entityName}Entity.${f.name} should have a value');`);
		}
	});
	js.add('');
	js.add(`const updates: {[name: string]: any} = {};`);
	_.each(table.fields, (f) => {
		if (!_.find(keys, {name: f.name})) {
			if (f.type === 'JSON') {
				if (f.notnull) {
					js.add(`updates.${f.name} = JSON.stringify(data.${f.name});`);
				} else {
					js.add(`updates.${f.name} = data.${f.name} ? JSON.stringify(data.${f.name}) : null;`);
				}
			} else if (f.jstype === 'boolean') {
				if (f.notnull) {
					js.add(`updates.${f.name} = data.${f.name} ? 1 : 0;`);
				} else {
					js.add(`updates.${f.name} = (data.${f.name} != null) ? (data.${f.name} ? 1 : 0) : null;`);
				}
			} else {
				js.add(`updates.${f.name} = data.${f.name};`);
			}
		}
	});
	if (keys.length === 1 && keys[0].auto_increment) {
		js.add(`
		await conn.update('INSERT INTO ${table.name} SET ?', [updates]);
		
		const rows = await conn.query('SELECT LAST_INSERT_ID() AS ${keys[0].name}');
		if (!rows.length) throw new Error('Cannot query LAST_INSERT_ID()');
		const ${keys[0].name} = rows[0].${keys[0].name};
		`);

	} else {
		js.add(`
		if (onDuplicateUpdate) {
			await conn.update('INSERT INTO ${table.name} SET ${pkWheres.join(', ')}, ? ON DUPLICATE KEY UPDATE ?', [${pkParams.join(', ')}, updates, updates]);
		} else {
			await conn.update('INSERT INTO ${table.name} SET ${pkWheres.join(', ')}, ?', [${pkParams.join(', ')}, updates]);
		}`);
	}
	js.add('');
	js.add(`
		return factory({...data, ${keyNames.join(', ')}}, conn);
	}`);
	js.add('');

	// private members
	_.each(table.fields, (f) => {
		if (_.find(keys, {name: f.name})) {
			js.add(`private _${f.name}: ${f.jstype};`);
		} else if (f.notnull) {
			js.add(`private _${f.name}: ${f.jstype};`);
		} else {
			js.add(`private _${f.name}: ${f.jstype} | null;`);
		}
	});
	js.add('');

	js.add(`
	private _conn: Connection;
	private _updates: {[name: string]: any};
	`);
	js.add('');

	// constructor
	js.add(`constructor(data: ${table.entityName}, conn: Connection) {`);
	_.each(table.fields, (f) => {
		if (_.find(keys, {name: f.name})) {
			js.add(`assert.notEqual(data.${f.name}, null);`);
			js.add(`this._${f.name} = data.${f.name};`);
		} else if (f.notnull) {
			js.add(`assert.notEqual(data.${f.name}, null);`);
			js.add(`this._${f.name} = data.${f.name};`);
		} else {
			js.add(`this._${f.name} = (data.${f.name} != null ? data.${f.name} : null);`);
		}
	});
	js.add(`
		this._conn = conn;
		this._updates = {};
	}`);
	js.add('');

	// setters and getters
	_.each(table.fields, (f) => {
		if (!_.find(keys, {name: f.name})) {
			if (f.notnull) {
				js.add(`set ${f.name}(value: ${f.jstype}) {`);
				if (f.type === 'JSON') {
					if (f.jstype.match(/^Array<.*>$/) || f.jstype.match(/.*\[\]$/)) {
						js.add(`if (!_.isArray(value)) throw new Error('${table.entityName}Entity.${f.name} should be an Array');`);
					} else {
						js.add(`if (!_.isPlainObject(value)) throw new Error('${table.entityName}Entity.${f.name} should be a PlainObject');`);
					}
				} if (f.jstype === 'boolean') {
					js.add(`if (!_.isBoolean(value)) throw new Error('${table.entityName}Entity.${f.name} should be a boolean');`);
				} else {
					js.add(`assert.notEqual(value, null);`);
				}

			} else {
				js.add(`set ${f.name}(value: ${f.jstype} | null | undefined) {`);
				if (f.type === 'JSON') {
					if (f.jstype.match(/^Array<.*>$/) || f.jstype.match(/.*\[\]$/)) {
						js.add(`if (value != null && !_.isArray(value)) throw new Error('${table.entityName}Entity.${f.name} should be an Array');`);
					} else {
						js.add(`if (value != null && !_.isPlainObject(value)) throw new Error('${table.entityName}Entity.${f.name} should be a PlainObject');`);
					}
				} else if (f.jstype === 'boolean') {
					js.add(`if (value != null && !_.isBoolean(value)) throw new Error('${table.entityName}Entity.${f.name} should be a boolean');`);
				}
			}
			js.add('');

			if (f.type === 'JSON') {
				js.add(`if (!_.isEqual(this._${f.name}, value)) {`);
			} else {
				js.add(`if (this._${f.name} !== value) {`);
			}

			if (f.notnull) {
				js.add(`this._${f.name} = value;`);
			} else {
				js.add(`this._${f.name} = (value != null ? value : null);`);
			}

			if (f.type === 'JSON') {
				if (f.notnull) {
					js.add(`this._updates.${f.name} = JSON.stringify(value);`);
				} else {
					js.add(`this._updates.${f.name} = value && JSON.stringify(value);`);
				}

			} else if (f.jstype === 'boolean') {
				if (f.notnull) {
					js.add(`this._updates.${f.name} = value ? true : false;`);
				} else {
					js.add(`this._updates.${f.name} = (value != null) ? (value ? 1 : 0) : null;`);
				}

			} else {
				js.add(`this._updates.${f.name} = value;`);
			}
			js.add(`
				}
			}`);
		}

		if (f.notnull) {
			js.add(`get ${f.name}(): ${f.jstype} { return this._${f.name}; }`);
		} else {
			js.add(`get ${f.name}(): ${f.jstype} | null | undefined { return this._${f.name} !== undefined ? this._${f.name} : null; }`);
		}
		js.add('');
	});

	js.add(`get conn(): Connection { return this._conn; }`);
	js.add('');

	// update()
	const thisPkParams = _.map(keys, (k) => `this._${k.name}`);
	js.add(`
	async update(): Promise<void> {
		if (this.isDirty()) {
			await this._conn.update1(
				'UPDATE ${table.name} SET ? WHERE ${pkWheres.join(' AND ')}',
				[this._updates, ${thisPkParams.join(', ')}]
			);
			this.clearDirty();
		} else {
			console.warn(new Error('${table.entityName}Entity has nothing to update'));
		}
	}`);
	js.add('');

	// updateIfDirty()
	js.add(`
	async updateIfDirty(): Promise<boolean> {
		if (this.isDirty()) {
			await this._conn.update1(
				'UPDATE ${table.name} SET ? WHERE ${pkWheres.join(' AND ')}',
				[this._updates, ${thisPkParams.join(', ')}]
			);
			this.clearDirty();
			return true;
		} else return false;
	}`);
	js.add('');

	// isDirty()
	js.add(`
	isDirty(): boolean {
		return Object.keys(this._updates).length ? true : false;
	}`);
	js.add('');

	// getDirty()
	js.add(`
	getDirty(): {[name: string]: any} {
		return this._updates;
	}`);
	js.add('');

	// clearDirty()
	js.add(`
	clearDirty(): void {
		this._updates = {};
	}`);
	js.add('');

	// toJSON()
	js.add(`
	toJSON(opts?: {includeNull?: boolean}): ${table.entityName} {
		const obj: ${table.entityName} = {
	`);
	_.each(table.fields, (f) => {
		if (f.notnull) {
			js.add(`${f.name}: this._${f.name},`);
		}
	});
	js.add('};');
	_.each(table.fields, (f) => {
		if (!f.notnull) {
			js.add(`if (this._${f.name} !== null && this._${f.name} !== undefined) obj.${f.name} = this._${f.name};`);
			js.add(`else if (opts && opts.includeNull) obj.${f.name} = null;`);
		}
	});
	js.add(`
		return obj;
	}`);
	js.add('');

	// fetch()
	js.add(`
	async fetch(): Promise<void> {
		const rows = await this.conn.query('SELECT * FROM ${table.name} WHERE ${pkWheres.join(' AND ')}', [${thisPkParams.join(', ')}]);
		if (!rows.length) throw new Error(\`No such #${table.entityName}Entity{${_.map(keys, (k) => k.name + ': ${this._' + k.name + '}').join(', ')}}\`);
		this.harvestFrom(rows[0]);
	}`);
	js.add('');

	// harvestFrom()
	js.add(`
	harvestFrom(row: {[name: string]: any}): void {
		${table.entityName}Entity.harvest(row, this)
	}`);

	js.add('}');
	js.add('');

	return js.toString();
};
