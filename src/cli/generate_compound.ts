import _ from 'lodash';

import { JsCoder } from '../lib/JsCoder';
import { ModulesCoder } from '../lib/ModulesCoder';
import { IField, ITable } from '../model';
import { Config, CustomJsTypes } from './spec';

const IMPORT_PATH_TO_CONNECTION = '../../lib/mysql-promise';
const IMPORT_PATH_TO_SCHEME_TYPES = 'mrshop-scheme/dist/types';
const IMPORT_PATH_TO_SCHEME_ENTITY = 'mrshop-scheme/dist/entity/types';

function getImports(compoundName: string, tables: ITable[], config: Config): string {
	const modules = new ModulesCoder();

	modules.importDefault('_', 'lodash');
	modules.import('Connection', IMPORT_PATH_TO_CONNECTION);

	for (const table of tables) {
		modules.import(`${table.entityName}Entity`, `./${table.entityName}.Entity.js`);

		for (const f of table.fields) {
			const jstypes = f.jstype.split(/[^a-zA-Z0-9_]+/);
			for (const jstype of jstypes) {
				if (!jstype.length) continue;

				if (CustomJsTypes.indexOf(jstype) >= 0) {
					modules.import(jstype, IMPORT_PATH_TO_SCHEME_TYPES);
				}
			}
		}
	}

	modules.import(compoundName, IMPORT_PATH_TO_SCHEME_ENTITY);

	return modules.toString()
}

function getPrimaryKeys(table: ITable): IField[] {
	let keyFields = _.filter(table.fields, (f) => f.pk);

	if (!keyFields.length) {
		const pkconstraint = _.find(table.constraints, (c) => c.match(/^PRIMARY\ KEY\(.*\)$/) ? true : false);
		if (!pkconstraint) throw new Error('No primary key for table: ' + table.name);

		const keyNames = pkconstraint.replace(/PRIMARY\ KEY\((.*)\)/, '$1').split(/,\s*/);
		if (!keyNames.length) throw new Error('No field in PRIMARY KEY');

		keyFields = [];
		for (const keyName of keyNames) {
			const field = _.find(table.fields, {name: keyName});
			if (!field) throw new Error('No such field of name: ' + keyName);
			keyFields.push(field);
		}
	}

	return keyFields;
}

export const generate_compound = (compoundName: string, tables: ITable[], config: Config): string => {
	const js = new JsCoder();
	js.add(`
	/* DO NOT EDIT THIS FILE:
	 * This file is generated by mrshop-gencode project.
	 */`);

	js.add(getImports(compoundName, tables, config).toString());
	js.add('');

	js.add(`export class ${compoundName}Entity {`);

	const entities = _.map(tables, (table) => ({name: table.entityName, alias: _.camelCase(table.name)}));
	const entityArgs = _.map(entities, (ent) => `${ent.alias}: ${ent.name}Entity`);

	// static harvest()
	js.add(`static harvest(row: {[name: string]: any}, dest?: any): ${compoundName} {`);
	js.add('if (!dest) dest = {};');
	_.each(entities, (e) => {
		js.add(`${e.name}Entity.harvest(row, dest);`);
	});
	js.add(`
		return dest;
	}`).br();

	// private members
	_.each(entities, (e) => {
		js.add(`private _${e.alias}: ${e.name}Entity;`);
	});
	js.add('');

	// constructor
	js.add(`constructor(${entityArgs.join(', ')}) {`);
	_.each(entities, (e) => {
		js.add(`this._${e.alias} = ${e.alias};`);
	});
	js.add('\t}');
	js.add('');

	const keys = getPrimaryKeys(tables[0]);

	// setters and getters
	_.each(tables, (table, tableIdx) => {
		_.each(table.fields, (f) => {
			if (_.find(keys, {name: f.name})) {
				if (!tableIdx) {
					js.add(`get ${f.name}() { return this._${entities[tableIdx].alias}.${f.name}; }`);
					js.add('');
				}

			} else {
				if (f.notnull) {
					js.add(`set ${f.name}(value: ${f.jstype}) { this._${entities[tableIdx].alias}.${f.name} = value; }`);
				} else {
					js.add(`set ${f.name}(value: ${f.jstype} | null | undefined) { this._${entities[tableIdx].alias}.${f.name} = value; }`);
				}

				js.add(`get ${f.name}() { return this._${entities[tableIdx].alias}.${f.name}; }`);
				js.add('');
			}
		});
	});

	js.add(`
	get conn(): Connection {
		return this._${entities[0].alias}.conn;
	}`);
	js.add('');

	// update()
	js.add(`
	async update() {
		let updated = false;
	`);
	_.each(entities, (e) => {
		js.add(`
		if (this._${e.alias}.isDirty()) {
			await this._${e.alias}.update();
			updated = true;
		}`);
	})
	js.add(`
		if (!updated) {
			console.warn(new Error('${compoundName}Entity has nothing to update'));
		}
	}`);
	js.add('');

	// updateIfDirty()
	js.add(`
	async updateIfDirty(): Promise<boolean> {
		let updated = false;
	`);
	_.each(entities, (e) => {
		js.add(`
		if (this._${e.alias}.isDirty()) {
			await this._${e.alias}.update();
			updated = true;
		}`);
	})
	js.add(`
		return updated;
	}`);
	js.add('');
		
	// isDirty()
	js.add('isDirty(): boolean {');
	_.each(entities, (e) => {
		js.add(`if (this._${e.alias}.isDirty()) return true;`);
	})
	js.add(`
		return false;
	}`);
	js.add('');

	// clearDirty()
	js.add('clearDirty(): void {');
	_.each(entities, (e) => {
		js.add(`this._${e.alias}.clearDirty();`);
	})
	js.add('}');
	js.add('');

	// toJSON()
	js.add(`
	toJSON(opts?: {includeNull?: boolean}): ${compoundName} {
		const obj: ${compoundName} = {
	`);
	_.each(tables, (table, tableIdx) => {
		_.each(table.fields, (f) => {
			if (_.find(keys, {name: f.name})) {
				if (!tableIdx) {
					js.add(`${f.name}: this._${entities[tableIdx].alias}.${f.name},`);
				}
			} else if (f.notnull) {
				js.add(`${f.name}: this._${entities[tableIdx].alias}.${f.name},`);
			}
		});
	});
	js.add('};');
	_.each(tables, (table, tableIdx) => {
		js.add(`const ${entities[tableIdx].alias} = this._${entities[tableIdx].alias};`);
		_.each(table.fields, (f) => {
			if (!f.notnull) {
				js.add(`
				if (${entities[tableIdx].alias}.${f.name} !== null && ${entities[tableIdx].alias}.${f.name} !== undefined) obj.${f.name} = ${entities[tableIdx].alias}.${f.name};
				else if (opts && opts.includeNull) obj.${f.name} = null;
				`);
			}
		});
	});
	js.add(`
		return obj;
	}`);
	js.add('');

	// fetch()
	js.add(`async fetch(): Promise<void> {`);
	_.each(entities, (e) => {
		js.add(`await this._${e.alias}.fetch();`);
	});
	js.add(`
		}
	}`);
	js.add('');

	return js.toString();
}
