import _ from 'lodash';

import { JsCoder } from '../lib/JsCoder';
import { ModulesCoder } from '../lib/ModulesCoder';
import { upperCamelCase } from '../lib/utils';
import { IField, ITable } from '../model';
import { CustomJsTypes } from './spec';

const IMPORT_PATH_TO_SCHEME_TYPES = '../../types';

export class InterfaceCodeGenerator {

	private name: string;

	constructor(private table: ITable, private options?: {prefix?: string, suffix?: string}) {
		this.name = upperCamelCase(`${options?.prefix || ''}_${table.entityName || table.name}_${options?.suffix || ''}`);
	}

	private getImports(): string {
		const modules = new ModulesCoder();
	
		for (const f of this.table.fields) {
			const jstypes = f.jstype.split(/[^a-zA-Z0-9_\.]+/);
			for (let jstype of jstypes) {
				if (!jstype.length) continue;
	
				if (jstype.indexOf('.')) {
					jstype = jstype.split('.')[0];
				} 
	
				if (CustomJsTypes.includes(jstype)) {
					modules.import(jstype, IMPORT_PATH_TO_SCHEME_TYPES);
				}
			}
		}
	
		return modules.toString();
	}
	
	private getPrimaryKeys(): IField[] {
		let keyFields = _.filter(this.table.fields, (f) => f.pk);
	
		if (!keyFields.length) {
			const pkconstraint = _.find(this.table.constraints, (c) => c.match(/^PRIMARY\ KEY\(.*\)$/) ? true : false);
			if (!pkconstraint) throw new Error('No primary key for table: ' + this.table.name);
	
			const keyNames = pkconstraint.replace(/PRIMARY\ KEY\((.*)\)/, '$1').split(/,\s*/);
			if (!keyNames.length) throw new Error('No field in PRIMARY KEY');
	
			keyFields = [];
			for (const keyName of keyNames) {
				const field = _.find(this.table.fields, {name: keyName});
				if (!field) throw new Error('No such field of name: ' + keyName);
				keyFields.push(field);
			}
		}
	
		return keyFields;
	}
	
	generate(): { name: string, content: string } {
		const js = new JsCoder();
		js.add(`
		/* DO NOT EDIT THIS FILE:
		 * This file is generated by mrshop-gencode project.
		 */`);
	
		js.add(this.getImports().toString());
		js.add('');
	
		const keys = this.getPrimaryKeys();
	
		// interface ~Data
		js.add(`export interface ${this.name}Data {`);
		_.each(this.table.fields, (f) => {
			if (!_.find(keys, {name: f.name})) {
				if (f.desc) {
					js.add(`/** ${f.desc} */`);
				}
				if (f.notnull) {
					js.add(`${f.name}: ${f.jstype};`);
				} else {
					js.add(`${f.name}?: ${f.jstype} | null;`);
				}
			}
		});
		js.add('}');
		js.add('');
	
		// interface entityName
		js.add(`export interface ${this.name} extends ${this.name}Data {`);
		_.each(keys, (f) => {
			if (f.desc) {
				js.add(`/** ${f.desc} */`);
			}
			js.add(`${f.name}: ${f.jstype};`);
		});
		js.add('}');
		js.add('');
	
		return {
			name: this.name,
			content: js.toString()
		}
	}
}
