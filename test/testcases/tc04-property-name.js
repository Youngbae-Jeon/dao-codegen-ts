const fs = require('fs');
const os = require('os');
const yaml = require('yaml');
const path = require('path');
const expect = require('chai').expect;
const { executeGeneration } = require('../../dist/cli/generate');

describe('속성 네이밍 스타일 테스트', () => {
	const prj = {};

	before(() => {
		const model = {
			table: 'product_sales_info',
			title: '품목정보',
			columns: {
				product_no: {
					title: '상품번호',
					type: 'int unsigned auto_increment primary key'
				},
				consumer_price: {
					title: '소비자가',
					type: 'int unsigned'
				},
				dsct_rate: {
					title: '할인율',
					type: 'numeric(6,2)',
					property: {
						name: 'discountRate'
					}
				}
			}
		};
		prj.dir = fs.mkdtempSync(path.join(os.tmpdir(), 'dcg-'))
		prj.modelDir = path.join(prj.dir, 'model');
		fs.mkdirSync(prj.modelDir);
		prj.modelFile = path.join(prj.modelDir, 'product_sales_info.yaml');
		fs.writeFileSync(prj.modelFile, yaml.stringify(model));
	});

	it('camel 스타일 타입스크립트 코드가 정상적으로 생성되어야 함', async () => {
		const generated = await executeGeneration({
			files: [
				prj.modelDir + '/**/*.yaml'
			],
			ts: {
				propertyNameStyle: 'camel',
				output: {
					dir: path.join(prj.dir, 'gen/dao')
				}
			}
		});
		expect(generated).to.have.property('ts_files');
		expect(generated.ts_files).to.deep.equal([`${prj.dir}/gen/dao/ProductSalesInfo.ts`]);

		const content = fs.readFileSync(generated.ts_files[0]).toString();
		expect(content).to.equal(`
// DO NOT EDIT THIS FILE:
// This file is generated from model file '../../model/product_sales_info.yaml'
// by dao-codegen-ts
// --------------------
import _ from 'lodash';
import assert from 'assert';
import mysql, { Connection, ResultSetHeader, RowDataPacket } from 'mysql2/promise';

export interface ProductSalesInfoData {
	/** 소비자가 */
	consumerPrice?: number | null;
	/** 할인율 */
	discountRate?: number | null;
}

/** 품목정보 */
export interface ProductSalesInfo extends ProductSalesInfoData {
	/** 상품번호 */
	productNo: number;
}

type Nullable<T> = { [P in keyof T]: T[P] | null };
type StatementType = 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE';
type LogFunction = (sql: string, options: {name: string, type: StatementType}) => void;

export class ProductSalesInfoDao {
	static harvestData(row: {[name: string]: any}): ProductSalesInfoData;
	static harvestData<T>(row: {[name: string]: any}, dest: T): ProductSalesInfoData & T;
	static harvestData(row: {[name: string]: any}, dest?: any) {
		if (!dest) dest = {};

		if (_.isNumber(row.consumer_price)) dest.consumerPrice = row.consumer_price;
		else if (row.consumer_price === null || row.consumer_price === undefined) dest.consumerPrice = null;
		else throw new TypeError('Wrong type for row.consumer_price');

		if (_.isNumber(row.dsct_rate)) dest.discountRate = row.dsct_rate;
		else if (row.dsct_rate === null || row.dsct_rate === undefined) dest.discountRate = null;
		else throw new TypeError('Wrong type for row.dsct_rate');

		return dest;
	}

	static harvest(row: {[name: string]: any}): ProductSalesInfo;
	static harvest<T>(row: {[name: string]: any}, dest: T): ProductSalesInfo & T;
	static harvest(row: {[name: string]: any}, dest?: any) {
		if (!dest) dest = {};

		if (_.isNumber(row.product_no)) dest.productNo = row.product_no;
		else if (row.product_no === null || row.product_no === undefined) throw new Error('row.product_no cannot be null');
		else throw new TypeError('Wrong type for row.product_no');

		this.harvestData(row, dest);
		return dest;
	}

	static assignData(dest: any, src: {[name: string]: any}): Partial<ProductSalesInfoData> {
		if (src.consumerPrice !== undefined) {
			dest.consumerPrice = src.consumerPrice;
		}
		if (src.discountRate !== undefined) {
			dest.discountRate = src.discountRate;
		}
		return dest;
	}

	static assign(dest: any, src: {[name: string]: any}): Partial<ProductSalesInfo> {
		if (src.productNo !== undefined) {
			if (src.productNo === null) throw new Error('src.productNo cannot be null or undefined');
			dest.productNo = src.productNo;
		}
		this.assignData(dest, src);
		return dest;
	}

	static toSqlValues(data: Partial<ProductSalesInfoData>): {[name: string]: any} {
		const params: {[name: string]: any} = {};
		if (data.consumerPrice !== undefined) {
			params.consumer_price = data.consumerPrice;
		}
		if (data.discountRate !== undefined) {
			params.dsct_rate = data.discountRate;
		}
		return params;
	}

	static log(stmt: string, type: StatementType, log?: LogFunction) {
		if (log) {
			log(stmt, {name: 'ProductSalesInfoDao', type});
		} else {
			console.log('ProductSalesInfoDao:', stmt);
		}
	}

	static async find(productNo: number, conn: Pick<Connection, 'execute'>, options?: {for?: 'update', log?: LogFunction}): Promise<ProductSalesInfo | undefined> {
		let sql = 'SELECT * FROM product_sales_info WHERE product_no=?';
		if (options?.for === 'update') sql += ' FOR UPDATE';

		const stmt = mysql.format(sql, [productNo]);
		this.log(stmt, 'SELECT', options?.log);

		const [rows] = await conn.execute<RowDataPacket[]>(stmt);
		if (rows.length) {
			return this.harvest(rows[0]);
		}
	}

	static async filter(by: Partial<Nullable<ProductSalesInfo>>, conn: Pick<Connection, 'execute'>, options?: {log?: LogFunction}): Promise<ProductSalesInfo[]> {
		const wheres: string[] = [];
		const params: any[] = [];
		const keys = Object.keys(by);
		for (const key of keys) {
			const val = (by as any)[key];
			if (val === undefined || val === null) {
				wheres.push(\`\${key} IS NULL\`);
			} else {
				wheres.push(\`\${key}=?\`);
				params.push(val);
			}
		}

		let stmt = \`SELECT * FROM product_sales_info\`;
		if (wheres.length) stmt += mysql.format(\` WHERE \${wheres.join(' AND ')}\`, params);
		this.log(stmt, 'SELECT', options?.log);

		const [rows] = await conn.execute<RowDataPacket[]>(stmt);
		return rows.map(row => this.harvest(row));
	}

	static async fetch(productNo: number, conn: Pick<Connection, 'execute'>, options?: {for?: 'update', log?: LogFunction}): Promise<ProductSalesInfo> {
		const found = await this.find(productNo, conn, options);
		if (!found) throw new Error(\`No such #ProductSalesInfo{productNo: \${productNo}}\`);
		return found;
	}

	static async query(sql: string, conn: Pick<Connection, 'execute'>, options?: {log?: LogFunction}): Promise<ProductSalesInfo[]> {
		this.log(sql, 'SELECT', options?.log);
		const [rows] = await conn.execute<RowDataPacket[]>(sql);
		return rows.map(row => this.harvest(row));
	}

	static async create(data: ProductSalesInfoData, conn: Pick<Connection, 'execute'>, options?: {log?: LogFunction}): Promise<ProductSalesInfo> {
		const params: {[name: string]: any} = {};
		if (data.consumerPrice === null || data.consumerPrice === undefined) params.consumer_price = null;
		else params.consumer_price = data.consumerPrice;

		if (data.discountRate === null || data.discountRate === undefined) params.dsct_rate = null;
		else params.dsct_rate = data.discountRate;

		const stmt = mysql.format('INSERT INTO product_sales_info SET ?', [params]);
		this.log(stmt, 'INSERT', options?.log);

		const [result] = await conn.execute<ResultSetHeader>(stmt);
		const productNo = result.insertId;
		return {...data, productNo};
	}

	static async update(origin: ProductSalesInfo, data: Partial<ProductSalesInfoData>, conn: Pick<Connection, 'execute'>, options?: {log?: LogFunction}): Promise<ProductSalesInfo> {
		if (origin.productNo === null || origin.productNo === undefined) throw new Error('Argument origin.productNo cannot be null or undefined');

		const updates = this.assignData({}, data);
		const params = this.toSqlValues(updates);

		const stmt = mysql.format(
			\`UPDATE product_sales_info SET ? WHERE product_no=?\`,
			[params, origin.productNo]
		);
		this.log(stmt, 'UPDATE', options?.log);

		const [result] = await conn.execute<ResultSetHeader>(stmt);
		assert(result.affectedRows === 1, \`More than one row has been updated: \${result.affectedRows} rows affected\`);

		return Object.assign(origin, updates);
	}

	static async delete(origin: ProductSalesInfo, conn: Pick<Connection, 'execute'>, options?: {log?: LogFunction}): Promise<void> {
		if (origin.productNo === null || origin.productNo === undefined) throw new Error('Argument origin.productNo cannot be null or undefined');

		const stmt = mysql.format(
			\`DELETE FROM product_sales_info WHERE product_no=?\`,
			[origin.productNo]
		);
		this.log(stmt, 'DELETE', options?.log);

		const [result] = await conn.execute<ResultSetHeader>(stmt);
		assert(result.affectedRows === 1, \`More than one row has been updated: \${result.affectedRows} rows affected\`);
	}
}
`.trimLeft()
		);
	});
	
	it('snake 스타일 타입스크립트 코드가 정상적으로 생성되어야 함', async () => {
		const generated = await executeGeneration({
			files: [
				prj.modelDir + '/**/*.yaml'
			],
			ts: {
				propertyNameStyle: 'snake',
				output: {
					dir: path.join(prj.dir, 'gen/dao')
				}
			}
		});
		expect(generated).to.have.property('ts_files');
		expect(generated.ts_files).to.deep.equal([`${prj.dir}/gen/dao/ProductSalesInfo.ts`]);

		const content = fs.readFileSync(generated.ts_files[0]).toString();
		expect(content).to.equal(`
// DO NOT EDIT THIS FILE:
// This file is generated from model file '../../model/product_sales_info.yaml'
// by dao-codegen-ts
// --------------------
import _ from 'lodash';
import assert from 'assert';
import mysql, { Connection, ResultSetHeader, RowDataPacket } from 'mysql2/promise';

export interface ProductSalesInfoData {
	/** 소비자가 */
	consumer_price?: number | null;
	/** 할인율 */
	discountRate?: number | null;
}

/** 품목정보 */
export interface ProductSalesInfo extends ProductSalesInfoData {
	/** 상품번호 */
	product_no: number;
}

type Nullable<T> = { [P in keyof T]: T[P] | null };
type StatementType = 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE';
type LogFunction = (sql: string, options: {name: string, type: StatementType}) => void;

export class ProductSalesInfoDao {
	static harvestData(row: {[name: string]: any}): ProductSalesInfoData;
	static harvestData<T>(row: {[name: string]: any}, dest: T): ProductSalesInfoData & T;
	static harvestData(row: {[name: string]: any}, dest?: any) {
		if (!dest) dest = {};

		if (_.isNumber(row.consumer_price)) dest.consumer_price = row.consumer_price;
		else if (row.consumer_price === null || row.consumer_price === undefined) dest.consumer_price = null;
		else throw new TypeError('Wrong type for row.consumer_price');

		if (_.isNumber(row.dsct_rate)) dest.discountRate = row.dsct_rate;
		else if (row.dsct_rate === null || row.dsct_rate === undefined) dest.discountRate = null;
		else throw new TypeError('Wrong type for row.dsct_rate');

		return dest;
	}

	static harvest(row: {[name: string]: any}): ProductSalesInfo;
	static harvest<T>(row: {[name: string]: any}, dest: T): ProductSalesInfo & T;
	static harvest(row: {[name: string]: any}, dest?: any) {
		if (!dest) dest = {};

		if (_.isNumber(row.product_no)) dest.product_no = row.product_no;
		else if (row.product_no === null || row.product_no === undefined) throw new Error('row.product_no cannot be null');
		else throw new TypeError('Wrong type for row.product_no');

		this.harvestData(row, dest);
		return dest;
	}

	static assignData(dest: any, src: {[name: string]: any}): Partial<ProductSalesInfoData> {
		if (src.consumer_price !== undefined) {
			dest.consumer_price = src.consumer_price;
		}
		if (src.discountRate !== undefined) {
			dest.discountRate = src.discountRate;
		}
		return dest;
	}

	static assign(dest: any, src: {[name: string]: any}): Partial<ProductSalesInfo> {
		if (src.product_no !== undefined) {
			if (src.product_no === null) throw new Error('src.product_no cannot be null or undefined');
			dest.product_no = src.product_no;
		}
		this.assignData(dest, src);
		return dest;
	}

	static toSqlValues(data: Partial<ProductSalesInfoData>): {[name: string]: any} {
		const params: {[name: string]: any} = {};
		if (data.consumer_price !== undefined) {
			params.consumer_price = data.consumer_price;
		}
		if (data.discountRate !== undefined) {
			params.dsct_rate = data.discountRate;
		}
		return params;
	}

	static log(stmt: string, type: StatementType, log?: LogFunction) {
		if (log) {
			log(stmt, {name: 'ProductSalesInfoDao', type});
		} else {
			console.log('ProductSalesInfoDao:', stmt);
		}
	}

	static async find(product_no: number, conn: Pick<Connection, 'execute'>, options?: {for?: 'update', log?: LogFunction}): Promise<ProductSalesInfo | undefined> {
		let sql = 'SELECT * FROM product_sales_info WHERE product_no=?';
		if (options?.for === 'update') sql += ' FOR UPDATE';

		const stmt = mysql.format(sql, [product_no]);
		this.log(stmt, 'SELECT', options?.log);

		const [rows] = await conn.execute<RowDataPacket[]>(stmt);
		if (rows.length) {
			return this.harvest(rows[0]);
		}
	}

	static async filter(by: Partial<Nullable<ProductSalesInfo>>, conn: Pick<Connection, 'execute'>, options?: {log?: LogFunction}): Promise<ProductSalesInfo[]> {
		const wheres: string[] = [];
		const params: any[] = [];
		const keys = Object.keys(by);
		for (const key of keys) {
			const val = (by as any)[key];
			if (val === undefined || val === null) {
				wheres.push(\`\${key} IS NULL\`);
			} else {
				wheres.push(\`\${key}=?\`);
				params.push(val);
			}
		}

		let stmt = \`SELECT * FROM product_sales_info\`;
		if (wheres.length) stmt += mysql.format(\` WHERE \${wheres.join(' AND ')}\`, params);
		this.log(stmt, 'SELECT', options?.log);

		const [rows] = await conn.execute<RowDataPacket[]>(stmt);
		return rows.map(row => this.harvest(row));
	}

	static async fetch(product_no: number, conn: Pick<Connection, 'execute'>, options?: {for?: 'update', log?: LogFunction}): Promise<ProductSalesInfo> {
		const found = await this.find(product_no, conn, options);
		if (!found) throw new Error(\`No such #ProductSalesInfo{product_no: \${product_no}}\`);
		return found;
	}

	static async query(sql: string, conn: Pick<Connection, 'execute'>, options?: {log?: LogFunction}): Promise<ProductSalesInfo[]> {
		this.log(sql, 'SELECT', options?.log);
		const [rows] = await conn.execute<RowDataPacket[]>(sql);
		return rows.map(row => this.harvest(row));
	}

	static async create(data: ProductSalesInfoData, conn: Pick<Connection, 'execute'>, options?: {log?: LogFunction}): Promise<ProductSalesInfo> {
		const params: {[name: string]: any} = {};
		if (data.consumer_price === null || data.consumer_price === undefined) params.consumer_price = null;
		else params.consumer_price = data.consumer_price;

		if (data.discountRate === null || data.discountRate === undefined) params.dsct_rate = null;
		else params.dsct_rate = data.discountRate;

		const stmt = mysql.format('INSERT INTO product_sales_info SET ?', [params]);
		this.log(stmt, 'INSERT', options?.log);

		const [result] = await conn.execute<ResultSetHeader>(stmt);
		const product_no = result.insertId;
		return {...data, product_no};
	}

	static async update(origin: ProductSalesInfo, data: Partial<ProductSalesInfoData>, conn: Pick<Connection, 'execute'>, options?: {log?: LogFunction}): Promise<ProductSalesInfo> {
		if (origin.product_no === null || origin.product_no === undefined) throw new Error('Argument origin.product_no cannot be null or undefined');

		const updates = this.assignData({}, data);
		const params = this.toSqlValues(updates);

		const stmt = mysql.format(
			\`UPDATE product_sales_info SET ? WHERE product_no=?\`,
			[params, origin.product_no]
		);
		this.log(stmt, 'UPDATE', options?.log);

		const [result] = await conn.execute<ResultSetHeader>(stmt);
		assert(result.affectedRows === 1, \`More than one row has been updated: \${result.affectedRows} rows affected\`);

		return Object.assign(origin, updates);
	}

	static async delete(origin: ProductSalesInfo, conn: Pick<Connection, 'execute'>, options?: {log?: LogFunction}): Promise<void> {
		if (origin.product_no === null || origin.product_no === undefined) throw new Error('Argument origin.product_no cannot be null or undefined');

		const stmt = mysql.format(
			\`DELETE FROM product_sales_info WHERE product_no=?\`,
			[origin.product_no]
		);
		this.log(stmt, 'DELETE', options?.log);

		const [result] = await conn.execute<ResultSetHeader>(stmt);
		assert(result.affectedRows === 1, \`More than one row has been updated: \${result.affectedRows} rows affected\`);
	}
}
`.trimLeft()
		);
	});


});
